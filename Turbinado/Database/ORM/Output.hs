module Turbinado.Database.ORM.Output where

import qualified Data.Char
import Control.Monad
import Data.Dynamic
import qualified Data.Map as M
import Data.Maybe
import Data.List
import Database.HDBC
import System.Directory
import System.FilePath

import Turbinado.Database.ORM.Types

type TypeName = String

-- TODO: This file needs to be completely torn up and generalized.

writeModels ts = 
  do writeFile "App/Models/Bases/ModelBase.hs" generateModelBase
     mapM_ (\(t, (cs, pk)) -> 
                 let typeName = (capitalizeName t)
                     fullName = typeName ++ "Model" in
                 do e <- doesFileExist (joinPath ["App/Models", fullName ++ ".hs"])
                    when (not e) (writeFile (joinPath ["App/Models", fullName++".hs"]) (generateModelFile typeName) ) 
                    writeFile (joinPath ["App/Models/Bases", fullName ++ "Base.hs"]) (generateModel t typeName pk cs)
           ) $ M.toList ts

---------------------------------------------------------------------------
--  File templates                                                       --
---------------------------------------------------------------------------

generateModel ::  TableName ->
                  TypeName ->
                  PrimaryKey -> 
                  Columns -> 
                  String
generateModel t typeName pk cs = 
  unlines $
  ["{- DO NOT EDIT THIS FILE"
  ,"   THIS FILE IS AUTOMAGICALLY GENERATED AND YOUR CHANGES WILL BE EATEN BY THE GENERATOR OVERLORD"
  ,""
  ,"   All changes should go into the Model file (e.g. ExampleModel.hs) and"
  ,"   not into the base file (e.g. ExampleModelBase.hs) -}"
  ,""
  ,"module Models.Bases." ++ typeName ++ "ModelBase ( "
  ," module Models.Bases." ++ typeName ++ "ModelBase, "
  ," module Models.Bases.ModelBase) where"
  , ""
  , "import Models.Bases.ModelBase"
  , "import System.Time"
  , ""
  , "data " ++ typeName ++ " = " ++ typeName ++ " {"
  ] ++
  [intercalate "," (map columnToFieldLabel (M.toList cs))] ++
  [ "    } deriving (Eq, Show)"
  , ""
  , "instance DatabaseModel " ++ typeName ++ " where"
  , "    tableName _ = \"" ++ t ++ "\""
  , ""
  ] ++
  generateFindByPrimaryKey t cs typeName pk ++
  generateFinders t cs typeName
 
generateModelFile typeName =
  unlines $
  ["module Models." ++ typeName ++ "Model"
  ,"  ( module Models." ++ typeName ++ "Model"
  ,"  , module Models.Bases." ++ typeName ++ "ModelBase"
  ,"  ) where"
  ,"import Models.Bases." ++ typeName ++ "ModelBase"
  ]

generateModelBase :: String
generateModelBase = unlines $
  ["{- DO NOT EDIT THIS FILE"
  ,"   THIS FILE IS AUTOMAGICALLY GENERATED AND YOUR CHANGES WILL BE EATEN BY THE GENERATOR OVERLORD -}"
  ,""
  ,"module Models.Bases.ModelBase ("
  ,"  module Models.Bases.ModelBase,"
  ,"  module Control.Exception,"
  ,"  module Database.HDBC,"
  ,"  module Data.Int"
  ,") where"
  ,""
  ,"import Control.Exception"
  ,"import Database.HDBC"
  ,"import Data.Int"
  ,""
  ,"{- Using phantom types here -}"
  ,"class DatabaseModel m where"
  ,"  tableName :: m -> String"
  ,""
  ,"type SelectString = String"
  ,"type SelectParams = [SqlValue]"
  ,""
  ,"class (DatabaseModel model) =>"
  ,"        HasFindByPrimaryKey model primaryKey | model -> primaryKey where"
  ,"    find :: IConnection conn => conn -> primaryKey -> IO model"
  ,""
  ,"class (DatabaseModel model) =>"
  ,"        HasFinders model where"
  ,"        findAll   :: IConnection conn => conn -> IO [model]"
  ,"        findAllBy :: IConnection conn => conn -> SelectString -> SelectParams -> IO [model]"
  ,"        findOneBy :: IConnection conn => conn -> SelectString -> SelectParams -> IO model"
  ,""
  ]

---------------------------------------------------------------------------
--  Generator templates                                                  --
---------------------------------------------------------------------------

generateFindByPrimaryKey :: TableName -> Columns -> TypeName -> PrimaryKey -> [String]
generateFindByPrimaryKey t cs typeName pk =
  case (length  pk) of
    0 -> [""]
    _ -> ["instance HasFindByPrimaryKey " ++ typeName ++ " " ++ " (" ++ unwords (intersperse "," (map (\c -> getHaskellTypeString $ colType $ fst $ fromJust $ M.lookup c cs) pk)) ++ ") " ++ " where"
         ,"    find conn pk@(" ++ (concat $ intersperse ", " $ map (\i -> "pk"++(show i)) [1..(length pk)]) ++ ") = do"
         ,"        res <- quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t ++ " WHERE (" ++ (generatePrimaryKeyWhere pk) ++ ")\") [" ++ (unwords $ intersperse "," $ map (\(c,i) -> "toSql pk" ++ (show i)) (zip pk [1..])) ++ "]"
         ,"        case res of"
         ,"          [] -> throwDyn $ SqlError"
         ,"                           {seState = \"\","
         ,"                            seNativeError = (-1),"
         ,"                            seErrorMsg = \"No record found when finding by Primary Key:" ++ t ++ " : \" ++ (show pk)"
         ,"                           }"
         ,"          r:[] -> return $ " ++ (generateConstructor cs typeName)
         ,"          _ -> throwDyn $ SqlError"
         ,"                           {seState = \"\","
         ,"                            seNativeError = (-1),"
         ,"                            seErrorMsg = \"Too many records found when finding by Primary Key:" ++ t ++ " : \" ++ (show pk)"
         ,"                           }"
         ]

generateFinders :: TableName -> Columns -> TypeName -> [String]
generateFinders t cs typeName =
    ["instance HasFinders " ++ typeName ++ " where"
    ,"    findAll conn = do"
    ,"        res <- quickQuery' conn \"SELECT " ++ cols cs ++ " FROM " ++ t ++ "\" []"
    ,"        return $ map (\\r -> " ++ generateConstructor cs typeName ++ ") res"
    ,"    findAllBy conn ss sp = do"
    ,"        res <- quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " WHERE (\" ++ ss ++ \") \")  sp"
    ,"        return $ map (\\r -> " ++ generateConstructor cs typeName ++ ") res"
    ,"    findOneBy conn ss sp = do"
    ,"        res <- quickQuery' conn (\"SELECT " ++ cols cs ++ " FROM " ++ t++ " WHERE (\" ++ ss ++ \") LIMIT 1\")  sp"
    ,"        return $ (\\r -> " ++ generateConstructor cs typeName ++ ") (head res)"
     ]

{-----------------------------------------------------------------------}
generatePrimaryKeyWhere pk = 
  unwords $
    intersperse "++ \" AND \" ++ \"" $
      map (\(c,i) -> c ++ " = ? ") (zip pk [1..])

generateConstructor cs typeName =
  typeName ++ " " ++ (unwords $
  map (\i -> "(fromSql (r !! " ++ (show i) ++ "))") [0..((M.size cs) - 1)])

 
---------------------------------------------------------------------------
--  Utility functions                                                    --
---------------------------------------------------------------------------
cols :: Columns -> String
cols cs = unwords $  intersperse "," $ M.keys cs

columnToFieldLabel :: (String, (SqlColDesc, ForeignKeyReferences)) -> String
columnToFieldLabel (name, (desc, _)) =
  "    " ++ partiallyCapitalizeName name  ++ " :: " ++ 
  (if ((colNullable desc) == Just True) then "Maybe " else "") ++
  getHaskellTypeString (colType desc)


getHaskellTypeString :: SqlTypeId -> String
getHaskellTypeString    SqlCharT = "String"
getHaskellTypeString    SqlVarCharT = "String"
getHaskellTypeString    SqlLongVarCharT = "String"
getHaskellTypeString    SqlWCharT = "String"
getHaskellTypeString    SqlWVarCharT = "String"
getHaskellTypeString    SqlWLongVarCharT = "String"
getHaskellTypeString    SqlDecimalT = "Rational"
getHaskellTypeString    SqlNumericT = "Rational"
getHaskellTypeString    SqlSmallIntT ="Int32"
getHaskellTypeString    SqlIntegerT = "Int32"
getHaskellTypeString    SqlRealT = "Rational"
getHaskellTypeString    SqlFloatT = "Float"
getHaskellTypeString    SqlDoubleT = "Double"
getHaskellTypeString    SqlTinyIntT = "Int32"
getHaskellTypeString    SqlBigIntT = "Int64"
getHaskellTypeString    SqlDateT = "ClockTime"
getHaskellTypeString    SqlTimeT = "ClockTime"
getHaskellTypeString    SqlTimestampT = "ClockTime"
getHaskellTypeString    SqlUTCDateTimeT = "ClockTime"
getHaskellTypeString    SqlUTCTimeT = "TimeDiff"
getHaskellTypeString    _ = error "Don't know how to translate this SqlTypeId to a SqlValue"


type SelectParameters = String

class TableType a where
  find   :: (IConnection conn) => conn -> Int -> a
  findBy :: (IConnection conn) => conn -> SelectParameters -> [a]

--  
-- Converts "column_name" to "ColumnName" (for types)
--
capitalizeName colname =
    concat $
      map (\(s:ss) -> (Data.Char.toUpper s) : ss) $
        words $
          map (\c -> if (c=='_') then ' ' else c) colname


--  
-- Converts "column_name" to "columnName" (for functions)
--
partiallyCapitalizeName colname =
  (\(s:ss) -> (Data.Char.toLower s) : ss) $
   capitalizeName colname 
